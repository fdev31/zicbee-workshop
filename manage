#!/usr/bin/env python
__all__ = ['Cloner', 'Workdir', 'Installer']

import os
import sys
import urllib
import shutil
import tempfile
import zipfile
import mercurial
from functools import partial
try:
    import _genexecutables
except ImportError:
    from . import _genexecutables

hivename = 'zicbee.zip'
ADM_PREFIX = 'sudo ' if os.system('sudo -v') == 0 else '' # XXX: os independent way ?
STATIC_EXTENSIONS = [] # for now sounds fine with pkg_resources :)

class Zipper(list):
    """ Object used to handle zip files """
    def __init__(self, zipname):
        self.name = zipname

    def extract(self, name=None, to_path=None, members=None, load=False):
        name = name or self.name
        zf = zipfile.ZipFile(name)
        if load:
            self[:] = [(x, '') for x in zf.namelist()]
        zf.extractall(to_path, members)
        zf.close()

    def save(self, as_name=None, prefix=''):
        name = as_name or self.name
        zf = zipfile.ZipFile(name, 'w', zipfile.ZIP_DEFLATED)
        for fname, dirname in self:
            zf.write(fname, prefix+fname[len(dirname):])
        zf.close()

class Cloner(object):
    """ After instantiation, you can use the get(name) method to get a zicbee component
    If mercurial is installed, it will use it, if not, just get the latest version zipfile and unpack
    """

    HOST = "http://zicbee.gnux.info/hg/index.cgi"

    def _hg_get(self, name):
        uri = "%s/%s"%(self.HOST, name)
        try:
            self._hg_clone(uri)
        except Exception, e:
            repo = self._hg_repo(name, False)
            self._hg_pull(repo, uri)
            self._hg_up(repo, 'tip')

    def _failsafe_get(self, name):
        uri = "%s/%s/archive/tip.zip"%(self.HOST, name)
        zipname = "%s.zip"%name
        site = urllib.urlretrieve(uri, zipname)
        zp = Zipper(zipname)
        zp.extract(load=True)
        dirname = zp[0][0].split( '/', 1)[0]
        if os.path.exists( os.path.join( name, '.hg')):
            print 'You are about to destroy the %s repository.\nIf you don\'t, zip file content is kept under "%s".'%(name, os.path.join(os.getcwd(), dirname))
            yn = raw_input('Do you want to proceed [yN] ? ')
            if not yn or yn[0].lower() != 'y':
                print "Not overwriting, install mercurial to have good update support."
                return
        shutil.rmtree(name)
        os.rename( dirname, name)

    def __init__(self):
        try:
            import mercurial.ui
            import mercurial.commands
            import mercurial.localrepo
            ui = mercurial.ui.ui()
            self._hg_clone = partial(mercurial.commands.clone, ui)
            self._hg_pull = partial(mercurial.commands.pull, ui)
            self._hg_up = partial(mercurial.commands.update, ui)
            self._hg_repo = partial(mercurial.localrepo.instance, ui)

        except ImportError:
            self.get = self._failsafe_get
        else:
            self.get = self._hg_get

class Workdir(object):
    """ Class to use with 'with' keyword, argument is a directory name.
    It will ensure the directory is properly created and chdir into it.
    """
    def __init__(self, name):
        self.old_path = os.getcwd()
        self.dirname = name

    def __enter__(self):
        for action in os.mkdir, os.chdir:
            try:
                action(self.dirname)
            except OSError, e:
                if e.args[0] != 17:
                    print "Can't %s : %s"%(action.__name__, e)
        return self.old_path

    def __exit__(self, a, b, c):
        os.chdir(self.old_path)

def rm(n):
    if os.path.exists(n):
        if os.path.isdir(n):
            shutil.rmtree(n)
        else:
            os.unlink(n)

class TempDir(object):
    def __init__(self):
        self.name = tempfile.mkdtemp('bee_', '_hive')

    def __enter__(self):
        return self.name

    def __exit__(self, a, b, c):
        print "Clean up..."
        rm(self.name)

class Installer(object):
    """ Zicbee installer object, all the high-level commands are here.
    The list of dependencies are hold in self.deps and the zicbee related projects are in self.softs
    Generally speaking, if things are not in place, then create it
    The methods can be directly linked to script arguments
    All commands assume you are in the parent directory of the copy of the project.
    """

    softs = 'zicbee-lib zicbee zicbee-mplayer zicbee-vlc'.split()
    deps = "simplejson web.py buzhug mutagen".split()

    def __init__(self):
        self.cloner = Cloner()
        self._egg_created = False
        self.force_gen = partial(self.gen_package, forced=True)

    def gen_package(self, forced=False):
        """ Will generate %s """%hivename
        # TODO: create "build" command that is called here
        j = os.path.join
        dist = 'dist'
        with TempDir() as tempdir:
            packages = self.deps + [j('dev', p) for p in self.softs]
            egg_name = 'bee.egg'

            zipper = Zipper(j(os.getcwd(), egg_name))
            for pkg in packages:
                fullpath = j(dist, pkg)
                egg = fullpath + '.egg'
                if forced or not os.path.exists(egg):
                    if not os.path.isfile(egg):
                        if not os.path.isdir(fullpath):
                            os.system("easy_install -U -e -b '%s' '%s'"%(dist, pkg))
                        for e in os.listdir(fullpath):
                            if e.endswith('.egg'):
                                rm(j(fullpath, dist, e))
                    with Workdir(fullpath):
                        rm(j(fullpath, 'build'))
                        rm(j(fullpath, 'dist'))
                        os.system('''python -c "import setuptools; execfile('setup.py')" bdist_egg''')
                        egg_file = [j(fullpath, 'dist', e) for e in os.listdir('dist') if e.endswith('.egg')][0]
                    shutil.move(egg_file, egg)
                print "extracting %s..."%egg
                zipper.extract(egg, tempdir)

            for unwanted in 'share', 'EGG-INFO':
                rm(j(tempdir, unwanted))

            for root, dirs, files in os.walk(tempdir):
                for d in dirs:
                    if d.startswith('test'):
                        rm(j(root, d))
            shutil.copytree(j('dev', 'EGG-INFO'), j(tempdir, 'EGG-INFO'))
            static_files = []
            for r, d, f in os.walk(tempdir):
                for n in f:
                    ext = n.rsplit('.', 1)[-1]
                    if ext in STATIC_EXTENSIONS:
                        static_files.append((j(r,n), tempdir))
                    elif ext not in ('pyo', 'pyc', 'swp', 'rej'):
                        zipper.append((j(r, n), tempdir))

            print "Saving %s..."%zipper.name
            zipper.save()
            with Workdir(tempdir) as old_dir:
                for fname in zipper:
                    rm(fname[0])
            rm(hivename)
            executables = [(e[0], '') for e in _genexecutables.executables]
            zipper[:] = static_files
            zipper.append((egg_name, ''))
            zipper.extend(executables)
            print "Saving %s..."%hivename
            sys.path.insert(0, os.path.join(os.curdir, egg_name))
            from zicbee import __version__ as ver
            sys.path.pop(0)
            root, ext = hivename.rsplit('.', 1)
            zipname = j("%s-%s.%s"%(root, ver, ext))

            foldername = zipname[:-4]
            zipper.save(zipname, prefix='%s%s'%(foldername, os.sep))
            print "Testing by extracting..."
            zipper.extract(zipname, members=(foldername + x[0][len(x[1]):] for x in static_files))
            with Workdir('release'):
                shutil.move(j(os.pardir, zipname), j(os.curdir, zipname))

    def cleanup(self, name):
        """ Will clean up .pyo and .pyc files in the given directory """
        for root, dirs, files in os.walk(name):
            for fname in files:
                if fname[-4:] in ('.pyo', '.pyc'):
                    os.unlink(os.path.join(root, fname))

    def pull(self, name):
        """ Clones the given project name """
        self.cloner.get(name)

    def mkbin(self):
        _genexecutables.gen()

    def install(self, name):
        """ Installs project via easy_install .pth files (links to project)  """
        cmd = '%s%s develop'%(ADM_PREFIX, os.path.join(os.curdir, 'setup.py'))

        with Workdir(name):
            os.chmod('setup.py', 0755)
            if os.system(cmd) != 0:
                raise RuntimeError("Can't run %s!"%cmd)


if __name__ == '__main__':
    inst_tool = Installer()
    default_cmds = ('pull', 'cleanup', 'mkbin', 'gen')
    commands = sys.argv[1:] if len(sys.argv)>1 else default_cmds
    l = []
    def print_help():
        print """Usage: %s <command> [command]...

default commands: %s

Commands:
gen     : Generates the %s, re-build project from sources if of the sources eggs are missing
fgen    : Generates the %s, re-build project from sources unconditionally
pull    : Pull latest changes from server, clone if not already here,
          fallbacks to unversioned folder (from zip).
mkbin   : Recreates the executable
cleanup : Removes those .pyc & .pyo files from projects
install : Easy_install develop zicbee related projects

use 'help' for help ;)"""%(sys.argv[0], ', '.join(default_cmds), hivename, hivename)

    cmd_handlers = {
            'gen': inst_tool.gen_package,
            'fgen': inst_tool.force_gen,
            'mkbin': inst_tool.mkbin,
            'help': print_help
            }

    global_cmds = []
    per_proj_cmds = []
    for cmd in commands:
        if cmd in cmd_handlers:
            global_cmds.append(cmd)
        else:
            per_proj_cmds.append(cmd)

    if per_proj_cmds:
        with Workdir('dev'):
            commands = [getattr(inst_tool, cmd) for cmd in per_proj_cmds if hasattr(inst_tool, cmd)]
            for soft in inst_tool.softs:
                for fn in commands:
                    name = "%s.%s"%(soft, fn.func_name)
                    try:
                        fn(soft)
                    except Exception, e:
                        l.append( (name, e) )
                    else:
                        l.append( (name, True) )

        if l:
            print "Status:"
            for name, res in l:
                print "[%s] %s"%(name, "OK" if res is True else res)
        else:
            print 'try "%s help".'%sys.argv[0]

    for cmd in global_cmds:
        cmd_handlers[cmd]()

